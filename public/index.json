[{"content":"Do you use tmux? Do you think the default key bndings of tmux unacceptalbe? Here are some tips I have collected.\nTIPS 1: Skip prefix After change some key bndings like prefix from C-b to something like C-space, you may still find annoying to press prefix for some handy shortcut like switching windows. To skips the needs of prefix, you may add the option -n before the command To switch windows without prefix using M-n 1 bind -n M-n select-window -t :+ 2: Keyboard Macros Macros are collection of keys sequence, you may find some key on your keyboard is less used like right alt, then you can convert this key as tmux specify modifier key, press this key will do a sequence of shortcut. To achieve this, you may need a key mappings application, on Linux I recommand kmonad; on Macos, I recommand Karabiner elements. If you use karabiner elements, use goku to configure Karabiner elements JSON file easier, life saver!\n3: open new window under current directory It is especially great working on small screen laptop, if you spawn new pane, then you are in the same directory, however, if you spawn a new window, you will by default at $HOME. You can use 1 bind -n M-o new-window -c \u0026#34;#{pane_current_path}\u0026#34; to map Alt-o to open new window udner current directory.\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog10/","summary":"Do you use tmux? Do you think the default key bndings of tmux unacceptalbe? Here are some tips I have collected.\nTIPS 1: Skip prefix After change some key bndings like prefix from C-b to something like C-space, you may still find annoying to press prefix for some handy shortcut like switching windows. To skips the needs of prefix, you may add the option -n before the command To switch windows without prefix using M-n 1 bind -n M-n select-window -t :+ 2: Keyboard Macros Macros are collection of keys sequence, you may find some key on your keyboard is less used like right alt, then you can convert this key as tmux specify modifier key, press this key will do a sequence of shortcut.","title":"Tmux key bndings less suffer"},{"content":"Obsidian is a local note-taking apps, all the files are saved as .md or .pdf format. Vim or Neovim are great editors that allow you config all days without writing any real code\nObsidian has vim-mode, which support Vim modal editing out of the box. However, due to the font size is not unqiue in obsidian, Like the heading has bigger size, the code block is not at the beginning of the line. Sometimes got confused when using jk to move up and down, you move up may not be where you want to go. Vim modal editing editing works better with mono font, regardly, mono font has less readibility than non-mono font where obsidian used by default. What\u0026rsquo;s more, obsidian vim-mode is not clone of vim, still implement as a vim emulation. You may have obsidian vimrc support plugin, so to unlock the power of mapping in obsidian, but you still got a lot limitation. In terms of editing, a real Vim should be better than any vim-emulation, and in terms of notes-taking, any note-taking app should work better than Vim+shell, you don\u0026rsquo;t have notes structure visualization without some extra tweaks.\nEditing in Vim With Vim, you can have those convenience over obsidian:\nsnippets completion The best \u0026ldquo;Vim\u0026rdquo; mode The last one should have no doubt. The reason I use snippets and completion in note-taking because I am lazy. Retype the same works again and again are really boring and meangless. Obsidian does have some plugins related to snippets and completion, but setup snippets and completion is just easier and more consisent on Vim. In Vim you can have same UI interface and consisent keyblindings. The plugins I use for snippets and completion are coc.nvim + Ultisnips + coc.snippets, choosing coc.nvim simply because it have provided solution for snippets together with completion out of the box. Of course, there is so much alternatives avalible. The only missing is the backlink completion. But it is fine, insert backlink in obsidian let me have a look of filenames, so that I won\u0026rsquo;t forget the filename and suck typing.\nExample configuration for snippets and completion:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Plug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;branch\u0026#39;: \u0026#39;release\u0026#39;} \u0026#34; coc.nvim inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; coc#pum#visible() \\ ? coc#pum#next(1) : \\ cocfunc#CheckBackspace() \\ ? \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; : coc#refresh() inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; coc#pum#visible() \\ ? coc#pum#prev(1) : \u0026#34;\\\u0026lt;S-TAB\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;CR\u0026gt; coc#pum#visible() \\ ? \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\\\u0026lt;c-r\u0026gt;=coc#pum#close()\\\u0026lt;CR\u0026gt;\u0026#34; \\ : \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\\\u0026lt;c-r\u0026gt;=coc#on_enter()\\\u0026lt;CR\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;space\u0026gt; coc#pum#visible() \\ ? \u0026#34;\u0026lt;esc\u0026gt;a\u0026lt;space\u0026gt;\u0026#34; : \u0026#34;\u0026lt;space\u0026gt;\u0026#34; \u0026#34; coc.snippets inoremap \u0026lt;C-j\u0026gt; \u0026lt;Plug\u0026gt;(coc-snippets-expand-jump) vnoremap \u0026lt;C-j\u0026gt; \u0026lt;Plug\u0026gt;(coc-snippets-select) let g:coc_snippet_next = \u0026#39;\u0026lt;C-j\u0026gt;\u0026#39; let g:coc_snippet_prev = \u0026#39;\u0026lt;C-k\u0026gt;\u0026#39; coc.snippets need to be installed separately, after install coc.nvim, run the command :CocInstall coc-snippets\nObsidian, the markdown viewer Insert image in markdown with plugins image resizer and imager inserter is supar convenient, no doubt better than vim.\nNavigation in wrapped line Since hard wrapped line will make paragraph look ugly in Obsidian, use soft wrapped line instead, which means one paragraph is actually a long long line. Some mapping will be handy to avoid keep using prefix g again in Vim.\nExample configuration, in ~/.vim/ftplugin/markdown.vim:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 setlocal textwidth=0 wrap formatoptions=tc2n linebreak noremap \u0026lt;buffer\u0026gt; j gj noremap \u0026lt;buffer\u0026gt; k gk noremap \u0026lt;buffer\u0026gt; $ g$ noremap \u0026lt;buffer\u0026gt; ^ g^ noremap \u0026lt;buffer\u0026gt; 0 g0 nnoremap \u0026lt;buffer\u0026gt; dd g0vg$D nnoremap \u0026lt;buffer\u0026gt; D g0vg$D nnoremap \u0026lt;buffer\u0026gt; V g0vg$ nnoremap \u0026lt;buffer\u0026gt; I g^i function! IsBlank() normal! g$ var char = getline(\u0026#34;.\u0026#34;)[col(\u0026#34;.\u0026#34;) - 1] if char == \u0026#34;\\t\u0026#34; || char == \u0026#34; \u0026#34; normal! gel startinsert else startinsert! endif deffunction nnoremap \u0026lt;buffer\u0026gt; A :call IsBlank()\u0026lt;cr\u0026gt; The last one help you stop at the last non-blank character in wrapped line, the normal behavior of g$a will stop at the last character including space and tab, sometimes inconvenient.\nPsudo WYSIWYG WYSIWYG, what you see is what you get, is one of the highlight of markdown syntax, very simple. To get half experience in Vim, oen can be turn on concealment. set conceallevel=2 to convert highlight syntax into unicode character.\nJust let better tools takes the jobs. For text editing, take Vim; For notes managment, take Obsidian; For complex data representaion like chart, embedded image and website page, just take any other tools like Notion.\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog9-prettyvim/","summary":"Obsidian is a local note-taking apps, all the files are saved as .md or .pdf format. Vim or Neovim are great editors that allow you config all days without writing any real code\nObsidian has vim-mode, which support Vim modal editing out of the box. However, due to the font size is not unqiue in obsidian, Like the heading has bigger size, the code block is not at the beginning of the line.","title":"Markdown writing, Obsidian + Vim, not vim-mode"},{"content":"Vacillate vim are really good, after remember some vim command keyblindings, you can start editing or writing immediately. The main benefits of using plugins can avoid use our poor vimscript. Use some great plugin avoid you to rebuild the wheel. Before you are able to write plugin yourself, trust me, any exist plugins is better than yours.\nPlugins recommendation 1. vim-plug vim-plug, a plugin manager that help you install, update and manage your plugins. Vim come with built-in package manger pack, a subdirectory under .vim/, if don\u0026rsquo;t exist, create it. I usually use build-in pack only for some personal little script, so that I don\u0026rsquo;t have to move forth and back in vim runtime path.\nVim plug syntax is easy, to add random plugins, add those line in your .vimrc:\n1 2 3 4 call plug#begin() \u0026#34; list plugins herer Plug \u0026#39;junegunn/vim-easy-align\u0026#39; call plug#end() Any github repo can be installed, for example, you have write your plugin and push to github at https://github.com/username/plugin-name, you can add this plugin by adding those line in your .vimrc:\n1 2 3 4 call plug#begin() \u0026#34; list plugins herer Plug \u0026#39;username/plugin-name\u0026#39; call plug#end() After that, save your file by :w, source your .vimrc or leave then reopen your .vimrc, run the command :PlugInstall. Plugins will be installed at ~/.vim/plugged by default.\nTo save my little pinky finger, I have those mapping for convenience:\n1 2 3 nnoremap \\i :w\u0026lt;cr\u0026gt;:source ~/.vim/vimrc\u0026lt;cr\u0026gt;:PlugInstall\u0026lt;cr\u0026gt; nnoremap \\c :w\u0026lt;cr\u0026gt;:source ~/.vim/vimrc\u0026lt;cr\u0026gt;:PlugClean\u0026lt;cr\u0026gt; nnoremap \\u :w\u0026lt;cr\u0026gt;:source ~/.vim/vimrc\u0026lt;cr\u0026gt;:PlugUpdate\u0026lt;cr\u0026gt; 2. vim-sandwich vim-sandwich help you to change the surround of text. What is surround? Surround means the pairs that surround text object, like \u0026quot; and (. It is handy to let program do for us, instead of change manually.\nvim-sandwich is an alternative of vim-surround, which provide texthighligh, auto-selection, and repeat with . out-of the box. It use less keys than vim-surround, just navigate to the current parenthesis object position and chagne the surround! No need to select the object before change. surround style of changing surround:\n1 cs \u0026lt;surround to be changed\u0026gt; \u0026lt;surround to replace\u0026gt; sandwich style of changing surround(auto replace):\n1 srb \u0026lt;surround to be changed\u0026gt; \u0026lt;surround to replace\u0026gt; I though it is a more intutitive than to surround style of change, as symbol like {, [ and ( is more difficult to type than navigate to the right position with f, t, F and T.\nThe auto-selection of vim-sandwich is highlight of this plugin, I have use this feaatur for all surround editing including add, delete and replace surrounds. I have the following setting so that I can use \u0026lt;leader\u0026gt;+symbols to add surround for one words or selected region\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 nmap \u0026lt;leader\u0026gt;( saiw(E nmap \u0026lt;leader\u0026gt;) saiw)E nmap \u0026lt;leader\u0026gt;[ saiw[E nmap \u0026lt;leader\u0026gt;] saiw]E nmap \u0026lt;leader\u0026gt;{ saiw{E nmap \u0026lt;leader\u0026gt;} saiw}E nmap \u0026lt;leader\u0026gt;\u0026#34; saiw\u0026#34;E nmap \u0026lt;leader\u0026gt;\u0026#39; saiw\u0026#39;E nmap \u0026lt;leader\u0026gt;\u0026lt; saiw\u0026lt;E nmap \u0026lt;leader\u0026gt;\u0026gt; saiw\u0026gt;E nmap \u0026lt;leader\u0026gt;` saiw`E nmap \u0026lt;leader\u0026gt;$ saiw$E nmap \u0026lt;leader\u0026gt;* saiw*.E nmap \u0026lt;leader\u0026gt;~ saiw~.E \u0026#34; visual vmap \u0026lt;leader\u0026gt;( sa( vmap \u0026lt;leader\u0026gt;) sa) vmap \u0026lt;leader\u0026gt;[ sa[ vmap \u0026lt;leader\u0026gt;] sa] vmap \u0026lt;leader\u0026gt;{ sa{ vmap \u0026lt;leader\u0026gt;} sa} vmap \u0026lt;leader\u0026gt;\u0026#34; sa\u0026#34; vmap \u0026lt;leader\u0026gt;\u0026#39; sa\u0026#39; vmap \u0026lt;leader\u0026gt;\u0026lt; sa\u0026lt; vmap \u0026lt;leader\u0026gt;\u0026gt; sa\u0026gt; vmap \u0026lt;leader\u0026gt;` sa` vmap \u0026lt;leader\u0026gt;$ sa$ vmap \u0026lt;leader\u0026gt;_ ca_ vmap \u0026lt;leader\u0026gt;* sa*. vmap \u0026lt;leader\u0026gt;~ sa~. However, it is a bad habits to make a keyboard macros, the better way would be calling the plugin\u0026rsquo;s function. Coz I am lazy and nothing happen till now, I keep those lines.\n3. clever-f clever-f is a plugin that improve the smoothness and consisent when navigation with f, t, F and T. You can use f to navigate to next f search, or use F to navigate backwards, instead of using ; and ,. What\u0026rsquo;s more, you can remap ; and , for other purpose. When you press f to navigate f search, you can cross the line, and you can have smart case searching!\nAfter using this plugin, I won\u0026rsquo;t claim it is more efficient than ; and ,, but it must be more comfortable.\nYou can change the behaviour of the plugins by adding those line to your .vimrc.\n1 2 3 4 5 6 7 8 9 10 11 \u0026#34; ignore case unless you specify Upper case let g:clever_f_smart_case = 1 \u0026#34; allow cross line, set to 1 if you don\u0026#39;t let g:clever_f_across_no_line = 0 like it \u0026#34; f; will searhc for all symbols let g:clever_f_chars_match_any_signs = \u0026#39;;\u0026#39; \u0026#34; f. will repeat you last search let g:clever_f_repeat_last_char_inputs = [ \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; ] 4. coc.nvim coc.nvim make completion in vim like vscode.\ncoc.nvim is a plugins framework, so you may find coc-XXX plugin written in Javascript or Typescript. Some of them is unique, some of them is alternative to the existing vim plugins to compatilbe with coc.nvim. One is coc.snippets, which aims to replace Ultisnips when you use coc.nvim. coc.nvim use is written Javascript and Typescript, you will configure the popup window in JSON file.\nBy default, coc.nvim don\u0026rsquo;t come with any keyblindings, you have to configure yourself.\nFor example, you can:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026#34; coc.nvim inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; coc#pum#visible() ? coc#pum#next(1) : \\ cocfunc#CheckBackspace() ? \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; : coc#refresh() inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; coc#pum#visible() ? coc#pum#prev(1) : \u0026#34;\\\u0026lt;S-TAB\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;CR\u0026gt; coc#pum#visible() ? \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\\\u0026lt;c-r\u0026gt;=coc#pum#close()\\\u0026lt;CR\u0026gt;\u0026#34; \\: \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\\\u0026lt;c-r\u0026gt;=coc#on_enter()\\\u0026lt;CR\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;space\u0026gt; coc#pum#visible() ? \u0026#34;\u0026lt;esc\u0026gt;a\u0026lt;space\u0026gt;\u0026#34; \\: \u0026#34;\u0026lt;space\u0026gt;\u0026#34; \u0026#34; coc.snippets inoremap \u0026lt;C-j\u0026gt; \u0026lt;Plug\u0026gt;(coc-snippets-expand-jump) vnoremap \u0026lt;C-j\u0026gt; \u0026lt;Plug\u0026gt;(coc-snippets-select) let g:coc_snippet_next = \u0026#39;\u0026lt;C-j\u0026gt;\u0026#39; let g:coc_snippet_prev = \u0026#39;\u0026lt;C-k\u0026gt;\u0026#39; The above example don\u0026rsquo;t require selection, you use \u0026lt;TAB\u0026gt; and \u0026lt;S-TAB\u0026gt; to navigate to the suggestion you want, after that, you can press \u0026lt;space\u0026gt; and \u0026lt;cr\u0026gt; to move and start a new line respectively.\n5. fzf.vim fzf.vim $\\times$ vim, a command line tools fzf vim warpper. You can unlock the power of fuzzy finder in vim nearly anything.\nThe syntax of fzf.vim is simple: :Files [PATH] search file in current directory by default :Buffers search opened buffers :Ag [PATTERN] use ag to search pattern :Rg [PATTERN] use rg to search pattern :Lines [QUERY] search lines in loaded buffers :Marks search marks and jump to :History serach for opened files :History: search fo Command history :History/ Search for searching history wiht / :Commands search for avalible Commands :Maps serahc for Normal mode mappings :Helptags fzf for :help XXX, open help buffer you can make your own shortcut like\n1 2 3 4 5 6 7 8 9 10 11 let g:fzf_preview_window = [\u0026#39;right,50%\u0026#39;, \u0026#39;ctrl-/\u0026#39;] let g:fzf_layout = {\u0026#39;window\u0026#39;: { \u0026#39;width\u0026#39;: 0.9, \u0026#39;height\u0026#39;: 0.9 }} let g:fzf_buffers_jump = 1 nnoremap \u0026lt;leader\u0026gt;ff :Files\u0026lt;cr\u0026gt; nnoremap \u0026lt;leader\u0026gt;fb :Buffers\u0026lt;cr\u0026gt; nnoremap \u0026lt;leader\u0026gt;fs :Lines\u0026lt;cr\u0026gt; nnoremap \u0026lt;leader\u0026gt;fp :Rg\u0026lt;cr\u0026gt; nnoremap \u0026lt;leader\u0026gt;f/ :History/\u0026lt;cr\u0026gt; nnoremap \u0026lt;leader\u0026gt;f: :History:\u0026lt;cr\u0026gt; nnoremap \u0026lt;leader\u0026gt;fh :Helptags\u0026lt;cr\u0026gt; The first line config the location of preview windows, you can have right, left, up, and down. The second line control the size of the popup windows\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog8-vimpluginrecommend/","summary":"Vacillate vim are really good, after remember some vim command keyblindings, you can start editing or writing immediately. The main benefits of using plugins can avoid use our poor vimscript. Use some great plugin avoid you to rebuild the wheel. Before you are able to write plugin yourself, trust me, any exist plugins is better than yours.\nPlugins recommendation 1. vim-plug vim-plug, a plugin manager that help you install, update and manage your plugins.","title":"Vim plugin recommendation"},{"content":"(Edited date: 2023-06-23T11:24:42+08:00)\nEmacs Evil mode, a Vi layer on top of Emacs, in my understanding, Evil is a collection of keys remapping that blinds Emacs function to vi style keys. I love elisp, its powerful expression, the robust ecosystem built on top of elisp, tones of API that help writing my own plugins. I thought it is the most apporach Vim emluation I have tried, if Emacs is start as emacs -nw, it will successly pretend Vim TUI!\nVscode-Neovim, it uses a fully embedded Neovim instance, so Vscode-Neovim can read the init.vim and init.lua. Which is really cool, don\u0026rsquo;t have to google the API before configuraion.\nHowever, I feel the gap when using them. They are great emluation of Vim modal editing, however, other than editing, some important values are still not able to copy, like the integration with shell, and relay on third parity plugin on their ecosystem. Moreoever, I don\u0026rsquo;t feel over advantage to use an emluation than native Vim.\nEmluation can\u0026rsquo;t Q to enter ex mode in Evil. q:, q?, q/in Vscode-Neovim(extremely useful!) sh in both.(sometimes I want to copy the previous command output) term in Vscode-Neovim to popup an termianl :help in Evil.\n(edited at Mon Jun 26 12:49:55 PM CST 2023)\nGravity Merge to new editor is harder than I thought, I have tried Vscode and Emacs, while they are great editor, but just required sometimes to copy the workflow from my old editor to new editor. Even copied all the keyblindings, some minor but unacceptable difference keep consumming my time to google a solution. For example, the Tab completion style difference between Vscode, Emacs and Vim, I like the popup window of Vim, the tab YouCompleteMe style tab cycling, to get the same setup on Emacs and Vscode are terrible.\nAlso, the greatest gravity fallback to the original editor is no productivity gain from switching. If finally I endup with the same writing and editing experience on other editors, I still reach the same level of speed and productivity, then so what? The core of those editor hasn\u0026rsquo;t changed, editing text, maybe Emacs can extand more than editing text.\nAfter giving a try to those editors, I finally satisify with my current editor. Just be reason when switching tools that have the same functionality in terms of your workflows, especially there is no issue with the current one.\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog7-tryevil/","summary":"(Edited date: 2023-06-23T11:24:42+08:00)\nEmacs Evil mode, a Vi layer on top of Emacs, in my understanding, Evil is a collection of keys remapping that blinds Emacs function to vi style keys. I love elisp, its powerful expression, the robust ecosystem built on top of elisp, tones of API that help writing my own plugins. I thought it is the most apporach Vim emluation I have tried, if Emacs is start as emacs -nw, it will successly pretend Vim TUI!","title":"Vim emluation on Emacs and Vscode"},{"content":"From Mac to Thinkpad 2020 Macbook Air with M1 chips, my first computer used in univserity. There is three reasons I brought it, light weight, no fans and long battery life. But surprisingly, I discover that they are no gaming changer when I get into univserity.\nThere is charger everywhere in univserity library, I don\u0026rsquo;t often move my computer, and I don\u0026rsquo;t have heavier work on my computer.\nSwitching is not correct in my situation, I don\u0026rsquo;t sold my Macbook, instead I brough a second hand Thinkpad x1 carbon 6th 2019. Nevertheless, I haven\u0026rsquo;t used my Macbook three month ago.\nThe reason I starting using thinkpad is so silly. After using Macbook for 9 months at univserity, I start to play with my keyboard, try different keyboard layout, also designed my own keyboard layout, I use Karabiner-Elements and Goku to config Karabiner Elements JSON file. Still there are some limitations on mac when remapping keys. Then, I discovered kmonad, which seems to be more powerful, more free, and more structured syntax when compare to terrible JSON indention. Sadly, I found kmonad do not work on my Macbook, and it seems to work better on Linux(I still don\u0026rsquo;t know the answer until now)?\nAfter the x1 carbon reached, I install Linux distribution and then kmonad immediately, Kmonad work perfect on linux! The silly fact is I have stopped tweaking my keyboard layout, I drop all the complex layer after using kmoand for a whole.\nSwitching gap No gap exist when switching, because I sedomly use Mac specified application, most of my favourite applications are cross platform, or have web version. Some application like mail and pdf editor are quite different on Linux and Macos, nevertheless, there is full documeted guide availible on univserity website. They are not an issue. Moreoever, most of the time I found myself living in browser, there will not be any significant difference in sense of user experience between Linux and Macos, instead of switching From Chrome to firefox. Google Chrome look like second class on linux, while Firefox have gesture supporting and smooth scrolling out of the box, Google Chrome haven\u0026rsquo;t come with gesture on my Linux distribution. But still, they are all fine.\nHabbits Change after on Thinkpad Switching has helped me discovering and changein my daily computer using habbits and my philosophy of desktop environment.\nFrom messay virtual desktop to organized workspace I had one bad habbit on Macos, I give every application a single virtual desktop, making switching application difficult. Suffering from sliding between virtual desktop or type the names of applications on spotlight search. Because of the implmentaton difference on GNOME and Macos, the workspace(equivalent to Macos virtual desktop) icon is so small, forcing me not to give one workspace per application. Since often I can\u0026rsquo;t memorize where are the applications, and it is difficult to look for the application on the tiny workspace icon. Nevertheless, I finally found the right usage of workspace, group related windows in the same workspace. I cannot count how much energy have been waste on finding the right location of the wanted applications.\nFrom tilling windows fans to floating windows fans Before doing meaningful stuff on computer, we first make ourself look cool, where 99% of time tweaking the desktop environment, remaining 1% doing real stuff.Tilling windows look cool, like hacker sitting in front of multiple screens. I use yabai on mac, before I try linux I have seen a lot of tilling windows manager screenshots sharing. They are really cool. But, most of the tilling windows manager are keyboard oriented, while the keyboard size of laptop are usually small, which mean I have to press keys with modifiers together, at the beginning, I am fine, but after a while, my little pinky finger suffer. I have rarely at the situation that have to switch between windows, of course no need for dynamic management of windows. I find floating windows is a more intuitive way to manage windows, and pinky-friendly.\nFrom 40% keyboard fans to 87% to 100% to 200%? 40% keyboard look cool, it hold you hand in four main rows, so it is more efficient. Um\u0026hellip;, that how I used to be thought about 40% keyboard, while saving thousand of miles finger move, I have to press every special symbols and numbers by modifiers, hold many key together, untypable if I move to new keyboard or new laptop. Currently I don\u0026rsquo;t get the philosophy of low profile keyboard, instead I prefer double keyboard now. Literaly high profile keyboard, 180% keyboard. Those extra keys are used as marcos. I saved those handy shortcut combination into single keys, like I have map \u0026ldquo;7\u0026rdquo; on numpad as \u0026ldquo;C-c C-t C-v enter\u0026rdquo;, \u0026ldquo;4\u0026rdquo; on numpad as my univserity mail address. I am so naive that I have implmented a 40% keyboard on Macbook keyboard, leaving the number rows unused HAHA. (Wombat 200% keyboard)\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog6-frommactothinkpad/","summary":"From Mac to Thinkpad 2020 Macbook Air with M1 chips, my first computer used in univserity. There is three reasons I brought it, light weight, no fans and long battery life. But surprisingly, I discover that they are no gaming changer when I get into univserity.\nThere is charger everywhere in univserity library, I don\u0026rsquo;t often move my computer, and I don\u0026rsquo;t have heavier work on my computer.\nSwitching is not correct in my situation, I don\u0026rsquo;t sold my Macbook, instead I brough a second hand Thinkpad x1 carbon 6th 2019.","title":"From Macbook to Thinkpad"},{"content":"There are too much time spend on configure my tools, replace a more efficiently tool with the less efficient one. It takes me so long to understand those apps doesn\u0026rsquo;t matter if just want to take a notes\nTime spending on notes taking app Effie When I have to take notes, I fisrt using Effie, but then I find it don\u0026rsquo;t have good image insert support, give up. Their idea is great, notes or writing apps should be clean enough and later I find every notes app say they are clean.\nNotion The next app is notion, it is great, the markdown blocks and integration of app make notion eye-cream, but then regarding the loading time take decade long, no offline support, and most of my time are dragging blocks make my workspace more pretty. \u0026ldquo;Um\u0026hellip; A good notes should look like this.\u0026rdquo;, regarding my terrible sense of beauty, the \u0026ldquo;design\u0026rdquo; never fit my imagination of prefect notes. Notion maybe too capable for a note taking app, the database function make them customizable, I want writing notes, but not build website. Nevertheelss, Notion now becoming my todo list, and event recorder, how great it support syncing across all devices, and can be access with browser.\nOneNote, CollaNote, Goodnotes, Remarkable All of them used to be kept my handwriting notes, among them, OneNotes is canva, CollaNote is vertical scrolling canva, Goodnotes is a good handwriting notes app but neet to pay. Remarkable is an accidient, I never understand why I think it can take a notes with high writing delay and slow responding time. All of them have been used on 2018 Ipad with 20.7 grams Apple Pencil (1st Generation). This gen pencil is too heavy, compare to Samsung 8 grams S Pen, it is like holding a sticker stamp on glass. I remember I have spend so much time finding free alternative on Ipad since good software and hardware are expensive, and finally stay with second hand Samsung tab S7.\nObsidian Before trying Obsidian, I have finally realize that note is simple as markdown, no need of those notion blocks or Effie cards. basiclly supporting tree directories selection and image insertion is a must. Obsidian do quite well, and finally I realize how much time is wasted on making my own notion note space. No database and todo list is needed, and therefore Obsidian is enough to write and manager notes.\nWhen tinkering a customizalbe tools, I always try to make the tools part of mine, try to complish all the tasks with the lovest tools. When there exist a better tools, still I have to use my lovely tools try to accomplish the task, if not, then google way to implement it. Most of the time tinkering the tools, losting the initial goal, turn into making my tools super powerful and multi-funcional. Therefore, never love your tools, getting the job done in efficient way is much more elegant than done the jobs with the specify tools, if the initial goal is getting the task done.\nEditor Editor is another time sink source. Vim is the first editor I know it is a editor, I have use vscode before but I don\u0026rsquo;t know it is a editor, back to the day using vscode, I am scaring of those UI, I don\u0026rsquo;t know what will happen if I turn on/off some of thems. Vim is clean, simple and elegant. However, it is like a mindset trap, the more I know Vim, the stronger will to do all in vim way. Vim bring me to shell, shell bring me to plain text operation. A mindset form, command line and plain text are efficient, GUI and mouse are evil. At that time, I have read many article of how to navigate laptop with only keyboard and vim like motion. Most of the time spend on google \u0026ldquo;how to do XXX in vim\u0026rdquo; and \u0026ldquo;how to do XXX in cli\u0026rdquo;. Still worse, I have imaged many situation that never happen, prepare a function or shortcut to overcome the problem never happen in future.\nAny customizalbe editor can be time sink to configure, they becoming toies insteat of tools, I am adding too much unnecessary function before applied in real context. All those function and shortcut should only solved and implment in fly or they are repetitive to give a handy marco. When some special case rise, I am aware if it can be handle in \u0026ldquo;simpler\u0026rdquo; way, the real is they seldom occur in the future. However, time is wasted already.\nProblems of upgrading productivity through changing tools. Replacing the current tools with a more productivity one is often handy and attactive, imaging better functionalility of newer tools and get the job more efficient and elegant. However most of the time is spent on move data and rebuild working flow. When I merge my notes from Effie to notion, it take me one day to do so, it is repeative and boring to copy all the structure of the notes.\nMy current strategy are of merging notes are don\u0026rsquo;t touch the notes unless necessary, most of my old notes are still keeping on notion instead merging them into obsidian, although it may feel statisfy too see a deep direcotry of notes on Obsidian side bar. It just too time consumming, no real benefit to merge all the notes into single place, whatever the notes still appear in both apps, it is really not difference to merge from one to one and separate them.\nChanging tools I always want to try new tools, like emacs, vscode, Obsidian open source alternative, Mac built-in preview.app \u0026ldquo;better alternative\u0026rdquo;. Try them like playing new toy, fun but no real gain. I try them under the name of learning, and end up with tinkering configure.\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog4-choose-of-tools/","summary":"There are too much time spend on configure my tools, replace a more efficiently tool with the less efficient one. It takes me so long to understand those apps doesn\u0026rsquo;t matter if just want to take a notes\nTime spending on notes taking app Effie When I have to take notes, I fisrt using Effie, but then I find it don\u0026rsquo;t have good image insert support, give up. Their idea is great, notes or writing apps should be clean enough and later I find every notes app say they are clean.","title":"Waste too much time to upgrade productivity"},{"content":"Abstraction Provide a way to dynamic swap numbers and symbols in vim according to current mode.\nHow this idea come When I write code or writing, I often find the symbols should be easily type as single key stroke, while in vim normal mode I find I would like to press number in single mode instead of pressing with shift. At first, I searched online for solution, many of them suggested to swap numbers and symbols, and I agree it may convient while coding. However, I am not coding all day, even during coding, in vim normal mode something it is handy to use number for [count] and command together. So swapping force you to choose one of them for more convenience typing. Another solution is to use number pad layer, I would say it is same as swapping, since I have to press with another key to use numbers, the problem havn\u0026rsquo;t been solved.\nOne day, When I was editing code, the idea of toggling nubmer-symbol row come in my mind, then I implement it, and find it solve the problem quite well regarding not prefect.\nNumber-symbols toggle Well, it is actually a dead key leader, when I press the toggle key which is equal sign of my keyboard. The nubmer row will swap to symbol row, press again, back to number.\nDynamic Number-symbols row in vim Since vim is modual, when insert mode, I prefer using symbols over numbers, when normal mode, I prefer the opposite. Then I add some rules for the toggle keys.\nBack to normal mode, which is equivalent to press the esc key, so when press esc key, define nst to False. It means toggle number rows.\n1 [:escape :left_control nil {:alone [ [\u0026#34;nst\u0026#34; 0] [\u0026#34;n-layer\u0026#34; 0] :escape ]} ] The above snippets is goku code, a config layer on top of Download Karabiner Elements, which is a tools for Mac to remap keyboard layouts.\nEnter insert mode, is equivalent to a, i, s, A, I, S, o, O, c, C. Then turn nst to True when type those key.\n1 2 3 4 5 [:i [:i [\u0026#34;nst\u0026#34; 1]]] [:a [:a [\u0026#34;nst\u0026#34; 1]]] [:s [:s [\u0026#34;nst\u0026#34; 1]]] [:c [:c [\u0026#34;nst\u0026#34; 1]]] [:o [:o [\u0026#34;nst\u0026#34; 1]]] The above code define nst to True when type i ( not I ).\nFurthur more, there is a few more situation I would prefer symbols over number, they are searching and command mode. Then I add those lines also.\n1 2 [:semicolon [:semicolon [\u0026#34;nst\u0026#34; 1]]] [:slash [:slash [\u0026#34;nst\u0026#34; 1]] ] Inprefect Since the layer is define outside vim, it can not avoid symbols row toggle during normal mode, when I type yip in normal mode, the symbol row toggle. Although I can have some line like inoremap 1 ! and cnoremap 2 @, I don\u0026rsquo;t want to pollute my mapping to much, I give up to implement this in pure vim way. I am interesting to find how to let karabiner know that I am in vim normal mode, so that avoid toggle symbol row accidently.\nI have remap equal sign to the caps lock, so it is possible for me to have one dead key, if you want to implement also, you may find your own.\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog3-dyn-num-sym/","summary":"Abstraction Provide a way to dynamic swap numbers and symbols in vim according to current mode.\nHow this idea come When I write code or writing, I often find the symbols should be easily type as single key stroke, while in vim normal mode I find I would like to press number in single mode instead of pressing with shift. At first, I searched online for solution, many of them suggested to swap numbers and symbols, and I agree it may convient while coding.","title":"Dynamic number-symbol row in vim"},{"content":"If you don\u0026rsquo;t know the basic syntax of Goku, please see the offical tutorial.\nWhat is Karabiner Elements? Karabiner Elements is a keyboard modifier on MacOS, which support key blindings remap and define layer, or in another form, complex modification. Download Karabiner Elements.\nWhat is Goku? Goku is a config file that ease the configuration in Karabiner Elements. In Karabiner Elements, if you want to implement complex modification, you will need to edit the json file, which is wired, it is very likely loss for beginners who don\u0026rsquo;t know the sturcture of modification of Karabiner Elements. Also, time is limited, why don\u0026rsquo;t use an easier tools that already on top of Karabiner Elements to make life easier? Goku on github\nDefine your customized layer 1. Why define layer The functionality of keyboard can be exteneded, one way is to define your own layers. With layers, you can shorten the key blindings in some \u0026ldquo;shortcut\u0026rdquo; usually require pressing three to four keys together. Or build an symbols layer if you stuck in the current number + shift way.\n2. Different types of layers Traditional layers Traditional layers like the layers of QMK mod-tap feature, a key\u0026rsquo;s function is divide into two, when you held down, it is modifier, and you loss its tap\u0026rsquo;s function, and vice verse.\nSimlayers In Goku, simlayer(simultianeous-layer) differ from traditional layers which you would not loss key\u0026rsquo;s original fucniton. For example, if you define f as your simlayer, if you held down f, stream of f will be inserted. Conversely, if you define f as tranditional layers, no f is insertd even you held it down.\nIn the tutorial of goku, author states the problems of traditional layers. But to me, they are the benefits, since simalayer have delayed display and require really fast right key followed. So, in this page, I would suggest you to use traditional layers.\nImplement layers with Goku 1. define variables. Variable help karabiner element know the state of your keyboard to act in performs different events in each states.\n1 [\u0026#34;name of variable\u0026#34; 0/1] It is a sturcture of variable, doble quoted name, 0 or 1 state.\n1 [:fookey [\u0026#34;foovar-set\u0026#34; 0/1] [\u0026#34;foovar-cd\u0026#34; 0/1]] It is conditional event, the last one is the condition, the middle one is to event, which set foovar-set to 0 or 1 if the condition is met.\n1 [:fookey [[\u0026#34;foovar1\u0026#34; 0/1] [\u0026#34;foovar2\u0026#34; 0/1]] [\u0026#34;foovar\u0026#34; 0/1]] It is same strcture of above but with extended to event, which set two variable in sequence, the condition part can also be extened in vector [[\u0026quot;foo1\u0026quot; 1] [\u0026quot;foo2\u0026quot; 1]], vector can expand as much as you want.\n2. mod-tap Layers This type of layer active if you held down fookey. inactive if you release.\n1 2 3 4 5 [:w [\u0026#34;tap_fookey\u0026#34; 1] nil { :alone [:w] :afterup [\u0026#34;tap_fookey\u0026#34; 0] :tap_fookey [:period :1 ] The first [\u0026quot;tap_fookey\u0026quot; 1] is the key event if you held down, alone is the key event if you tap single. :afterup is after key up event. The last line :tap_fookey tells karabiner to perform the following events if \u0026quot;tap_fookey\u0026quot; is met, In this example, it is w+. -\u0026gt; 1 it is like the conditions.\n3. dead keys This type of layer active if you press fookeys, inactive if you press the fooleavekey.\n1 2 3 4 5 [:fookey [\u0026#34;dead_foo\u0026#34; 1]] [:fooleavekey [\u0026#34;dead_foo\u0026#34; 0]] :dead_foo [:foo_from [:foo_to [\u0026#34;dead_foo\u0026#34; 0]]] [:foo_from :foo_to ] Dead key is actually a simple layer checked with variales state, the first event in dead_foo will leave layer after press the foo_from, while the second won\u0026rsquo;t. If you wish to leave the layer with the same keys you can:\n1 2 3 4 [:comma [\u0026#34;taped\u0026#34; 0] [\u0026#34;taped\u0026#34; 1 ] ] [:comma [\u0026#34;taped\u0026#34; 1] [\u0026#34;taped\u0026#34; 0 ] ] :taped [:period :1 ] double tap layer 1 2 3 4 5 6 7 8 9 10 11 ;; check double tap [:right_shift [\u0026#34;two\u0026#34; 1] [\u0026#34;one\u0026#34; 1]] ;; chekc single tap [:right_shift :right_shift nil {:alone [:right_shift [\u0026#34;one\u0026#34; 1]] :delayed {:invoked [\u0026#34;one\u0026#34; 0] :canceled [\u0026#34;one\u0026#34; 0]} :params {:delay 1000}}] :two [:period :1 ] This layer keep the function of right shift, but I don\u0026rsquo;t know why it fail to use right shift to escape. The single tap check is a little bit complicate, nil is introduced in mod-tap layer which extended the to event, new :delayed control the behaviour after the key tapped, :invoked and :canceled work as their name. :params {:delay 1000} denote the time for the accepted delay time, invoked event trigger before that time, canceled event trigger after that time. The double tap check should be put before single tap check. To escape the layer use the same key use the follow snippet instead:\n1 2 3 4 5 6 7 8 9 10 11 ;; check double tap [:right_shift [\u0026#34;two\u0026#34; 1] [\u0026#34;one\u0026#34; 1]] ;; chekc single tap [:right_shift [:right_shift [\u0026#34;one\u0026#34; 1]] [\u0026#34;two\u0026#34; 0] {:delayed {:invoked [\u0026#34;one\u0026#34; 0] :canceled [\u0026#34;one\u0026#34; 0]} :params {:delay 1000}}] :two [:right_shift [\u0026#34;two\u0026#34; 0]] [:period :1 ] It first check that if right_shift is tap twice and once, and leave if tap twice already. But this cannot perserve the function of right shift, so it cannnot be act like modifier anymore, to be noted, the last example that perserve right shift can replace by othey with variables, so as mod-tap layer and double tapped layer at the same time.\nMarco This is actually not a layer, but a collection of keys. I have defined a layer to shorten repetitive keys sequence into single press.\n1 [:i [:i :n :s :e :r :t :spacebar :a :spacebar :j :o :k :e]] Which will insert insert a joke with space if you press i.\nMy karabier.edn Here is a reference for your own implementation.\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog2-goku/","summary":"If you don\u0026rsquo;t know the basic syntax of Goku, please see the offical tutorial.\nWhat is Karabiner Elements? Karabiner Elements is a keyboard modifier on MacOS, which support key blindings remap and define layer, or in another form, complex modification. Download Karabiner Elements.\nWhat is Goku? Goku is a config file that ease the configuration in Karabiner Elements. In Karabiner Elements, if you want to implement complex modification, you will need to edit the json file, which is wired, it is very likely loss for beginners who don\u0026rsquo;t know the sturcture of modification of Karabiner Elements.","title":"Define layer using Karabiner Elements togther with Goku"},{"content":"Abstruct 2023 is a start of AI era, with more strong AI tools explore to our life, typing maybe replaced by voice input one day, where natural language programming become true. But until now, typing is still not replacable. From daily usage to programming, the location of the keys may significantly effect the comfortable of long time typing. Here is a brief solution that hope to enhance the experience when typing on standard 78% keyboard.\nReason to redesign. I use Macbook Air as my main machine, stick to it and cannot use an customizable keyboard like planck\u0026rsquo;s keyboard and hhkb keyboard for the desire of protable. The plain of using standard 78% keyboard on Macbook is the overusage of pinky, Backspace, [, ], -, = and Enter are all handled by right pinky. As my right pinky is much weaker than left, which make typing long time a difficult, inefficient and tired task. I believe it is true for other user who programming a lot with Macbook.\nThere are so many plans and existing well designed layouts on the Internet, while they are mainly for one who use a external non-standard keyboards instead of standard. So I hope there will be more disscusion about configuration of trivail standard keyboard.\nChoose of base layer, Qwerty Not Colemak, Dvoark and any non-Qwerty. I have tried Colemak and Dvoark, but the musale memory of Qwerty is too strong that make me feel more natural and comfortalbe typing on Qwerty. Moreover, the change of layout may not bring significant advantages and comfor for typing, 10 keys on homerow is never enough, whatever layouts, your fingers still need to move along three rows to type characters. The analysis of those Qwerty alternative always be to ideal, without mention of muscale memory and symbols make such change not really solve the plain. Another reason is that the time cost is too high and the improvement is not that big, there is not need to explain why the time cost is high as it is well explained by those Qwetrty touch typer how share their experience of switching to non-Qwerty.\nAnalysis before design Except the function row, all row is easier to reach even for number rows. I don\u0026rsquo;t touch type numbers rows using pinky fingers. Instead, I use ring fingers which are much longers then pinky fingers. So the keyboard layout don\u0026rsquo;t need to relay on layers heavily like 40% planck\u0026rsquo;s keyboard.\nLet counts the key we need:\n30 characters on the main area of the keyboard including ,, ., / and ;. 13 keys on numbers 8 modifier keys, capslock, left right option, left right command, left shift, control, fn I don\u0026rsquo;t count right shift since I never use it. 4 special keys, including space, reutrn, tab and delete. 4 arrow keys, I don\u0026rsquo;t want to use home row arrow keys, since I seldom use them, there is no need to prepare a layer for them. 61 keys is already sweat enough for daily used, for those shortcut, I usually reduce them from three or above keys into two keys by define a customizing layer.\nLayers There are two types of layers, dead keys and modifers\nDead keys The layout of keyboard is chagned permanently untill you press other keys or the inactive keys. One of the exmaple are the comma of workman-dead.\nmodifers The layout is changed temporary, the layout return to default after release. One of the example is shift.\nMy solution There are some keys that is underused, like space, tab and return. There are much space that can be leveraged. They should perform tap-mode, which provide two funciton when tap and held them down.\nRemap space to space when tap, shift when held. It is much comfortable compare to use pinky finger to press shift. Remap left shift to escape when tap, control when held. I use vim. swap numbers and symbols for programming. remap caps lock to = when tap, switch layer when held. swap quote ' and double quote ', and locate at the original position of open bracket. move hyphen and underscore to the original position of quote. move backslash and pipe to the original position of hyphen. Layers: caps lock layers(held down caps lock): u: ] i: [ j: } k: {\nMacro sequences You can define a simple key that perform a sequence of key. It is better put them in a layer to avoid error when typing. I have defined some in the caps lock layer. d: -\u0026gt; f: != :: @:\nImplementation You may wonder how to implement those change on Mac, you may use Karabiner Elements together with Goku to define your own keyboard layout.\nConclusion There are lots of method to increase comfortable and efficiency to get the job done, before typing to modify your keyboard, make sure you have tried to use good tools like Vim, IDE, auto compeletion, snippets and scritping to reduece typing. Single modification of keyboard won\u0026rsquo;t make you a better typer.\nWith the help of snippets and auto completion, I now write code with less demand to type all the symbols manually, therefor a entire symbols layers on homerow is no needed(Previously I have one, use space to active, convert home row into common used symbols.)\n","permalink":"https://sokinpui.github.io/blog-sokinpui/post/blog1-layout/","summary":"Abstruct 2023 is a start of AI era, with more strong AI tools explore to our life, typing maybe replaced by voice input one day, where natural language programming become true. But until now, typing is still not replacable. From daily usage to programming, the location of the keys may significantly effect the comfortable of long time typing. Here is a brief solution that hope to enhance the experience when typing on standard 78% keyboard.","title":"Programmer MacBook Keyboard layout"},{"content":" Find me on: Github: sokinpui Mail: sokinpui\n","permalink":"https://sokinpui.github.io/blog-sokinpui/about/","summary":"Find me on: Github: sokinpui Mail: sokinpui","title":"About"}]